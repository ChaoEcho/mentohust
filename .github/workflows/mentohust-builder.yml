# 工作流名称
name: Build MentoHUST for x86_64 Snapshot

# 1. 工作流触发器
# 设置为 "workflow_dispatch"，允许您从 GitHub 仓库的 "Actions" 标签页手动触发此构建流程。
on:
  workflow_dispatch:

jobs:
  build:
    # 任务名称
    name: Build for x86_64
    # 使用最新的 Ubuntu 环境进行构建
    runs-on: ubuntu-latest

    steps:
      # 步骤1：签出您的仓库代码到正确的路径
      # 使用path参数将代码checkout到'./mentohust'目录，符合SDK预期
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          path: './mentohust'
          fetch-depth: 0

      # 步骤2：调试 - 显示目录结构和文件内容
      - name: Debug - Show directory structure and files
        run: |
          echo "=== Current working directory ==="
          pwd
          echo "=== Directory structure ==="
          find . -type f -name "*.mk" -o -name "Makefile" -o -name "*.c" -o -name "*.h" | head -20
          echo "=== mentohust directory contents ==="
          ls -la ./mentohust/ || echo "mentohust directory not found"
          echo "=== Makefile content (if exists) ==="
          cat ./mentohust/Makefile || echo "Makefile not found"

      # 步骤3：使用 OpenWrt 官方 SDK Action 编译软件包
      # 这是核心步骤，它会自动处理 SDK 下载、链接源码和编译。
      - name: Build MentoHUST package
        uses: openwrt/gh-action-sdk@main
        env:
          # 使用 snapshot 版本以匹配 OpenWrt 24.10.2 目标系统
          # 24.10 是开发分支，通常使用 snapshot 标识符
          ARCH: x86_64-snapshot
          
          # 告诉 Action 去编译您仓库中哪个目录下的软件包。
          # Action 会在 'mentohust' 目录中寻找包。
          PACKAGES: mentohust
          
          # 自定义 feed 的名称，这是一个标准的默认值。
          FEEDNAME: packages_ci
          
          # 禁用刷新检查以避免构建问题
          NO_REFRESH_CHECK: true
          
          # 启用详细输出模式以获得更多调试信息
          V: sc

      # 步骤4：构建失败时的调试信息
      - name: Debug - Show build environment on failure
        if: failure()
        run: |
          echo "=== Build failed, showing debug information ==="
          echo "=== Current directory structure ==="
          find . -name "*.log" -o -name "*.err" -o -name "*error*" | head -10
          echo "=== Check for build logs ==="
          find /builder -name "*.log" 2>/dev/null | head -5 || echo "No build logs found in /builder"
          echo "=== Check package directory ==="
          ls -la /feed/package/ 2>/dev/null || echo "No /feed/package/ directory"
          ls -la package/ 2>/dev/null || echo "No package/ directory"
          echo "=== Environment variables ==="
          env | grep -E "(ARCH|PACKAGES|FEEDNAME)" || echo "No relevant env vars"

      # 步骤5：检查生成的IPK文件位置
      - name: Debug - Find generated IPK files
        run: |
          echo "=== Searching for IPK files ==="
          find . -name "*.ipk" -type f 2>/dev/null || echo "No .ipk files found in current directory"
          echo "=== Checking bin directory structure ==="
          ls -la bin/ 2>/dev/null || echo "No bin directory"
          find bin/ -name "*.ipk" 2>/dev/null || echo "No .ipk files in bin directory"
          echo "=== Checking all possible package directories ==="
          find . -path "*/packages/*" -name "*.ipk" 2>/dev/null || echo "No packages found"

      # 步骤6：将编译好的 .ipk 文件打包为构建产物
      # 这会让您可以在 Actions 运行结束后，轻松地下载到最终的安装包。
      - name: Upload IPK artifact
        uses: actions/upload-artifact@v4
        with:
          name: mentohust-ipk-x86_64
          path: bin/packages/x86_64/*/*.ipk
          if-no-files-found: warn

